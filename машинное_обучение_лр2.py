# -*- coding: utf-8 -*-
"""машинное_обучение_лр2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cvVxoPQH-7_v3zH41S45FkDjHvZkU4_4

# Создание шаблонов эмодзи
"""

# Импорт нужных библиотек
import numpy as np
import matplotlib.pyplot as plt
import random

# Матричное представление эмодзи
smile = [[0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
         [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
         [1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
         [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
         [1, 0, 0, 1, 1, 1, 1, 0, 0, 1],
         [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
         [0, 0, 1, 1, 1, 1, 1, 1, 0, 0]]


fatigue = [[0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
           [1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
           [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
           [1, 0, 0, 1, 1, 1, 1, 0, 0, 1],
           [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
           [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
           [0, 0, 1, 1, 1, 1, 1, 1, 0, 0]]


coolness = [[0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
           [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
           [1, 0, 0, 0, 1, 1, 0, 0, 0, 1],
           [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
           [0, 0, 1, 1, 1, 1, 1, 1, 0, 0]]    

# Отображение эмодзи
fig, ax = plt.subplots(1, 3)
fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"
ax[0].imshow(smile)
ax[1].imshow(fatigue)
ax[2].imshow(coolness)
ax[0].set_title('smile')
ax[1].set_title('fatigue')
ax[2].set_title('coolness')
plt.show()

"""# Нейронная сеть Хопфилда

Создаем класс нейронная сеть Хопфилда
"""

class Hopfield:
    def __init__(self, n): # размер изображения
        self.weights = np.zeros((n, n))
    
    def train(self, data): # Данные для обучения
        n = len(data)
        for i in range(n):
            for j in range(n):
                if i != j:
                    self.weights[i][j] += data[i] * data[j] 
    
    def predict(self, data): # Предсказание
        n = len(data)
        output = np.zeros(n)
        for i in range(n):
            output[i] = np.sign(np.dot(self.weights[i], data))
        return output

"""Функция обучения и распознавания образов эмодзи с n количеством зашумленными элементами"""

def emoji_recognition(emoji, number_noise): # number_noise - количество зашумленных элементов
  # Вывод шаблона эмодзи
  fig, ax = plt.subplots(1, 3)
  fig.set_figwidth(12)    #  ширина и
  fig.set_figheight(12)    #  высота "Figure"
  ax[0].imshow(emoji)
  ax[0].set_title('Шаблон эмодзи')

  # Преобразуем изображение в одномерный массив
  emoji_flattened = emoji.flatten()

  # Создаем модель класса и обучаем
  hopfield = Hopfield(len(emoji_flattened))
  hopfield.train(emoji_flattened)

  # Создание эмодзи с шумом
  noisy_emoji = emoji
  # Из шаблонной матрицы делаем с шумум путем изменения элементов матрицы
  positions = random.sample([(i, j) for i in range(len(noisy_emoji)) for j in range(len(noisy_emoji[i]))], number_noise)
  for pos in positions:
      i, j = pos
      noisy_emoji[i][j] = 1 if noisy_emoji[i][j] == 0 else 0

  # Преобразуем эмодзи в одномерный массив
  noisy_emoji_flattened = noisy_emoji.flatten()

  # Прогнозируем зашумленное изображение с помощью нейронной сети Хопфилда
  predicted_noisy_emoji_flattened = hopfield.predict(noisy_emoji_flattened)

  # Преобразуем предсказанное изображение в 2D-массив
  predicted_noisy_emoji = predicted_noisy_emoji_flattened.reshape(10, 10)

  # Вывод результатов обучения
  ax[1].imshow(noisy_emoji)
  ax[2].imshow(predicted_noisy_emoji)
  ax[1].set_title('Эмодзи с шумом')
  ax[2].set_title('Результат')
  plt.show()

"""# Работа нейронной сети на распознавание образов

Распознавание эмодзи с 3 искаженными элементами
"""

emoji_recognition(np.array(smile), 3)

"""Распознавание эмодзи с 40 искаженными элементами"""

emoji_recognition(np.array(fatigue), 40)

"""Распознавание эмодзи с 70 искаженными элементами"""

emoji_recognition(np.array(coolness), 70)

"""Распознавание эмодзи с 90 искаженными элементами"""

emoji_recognition(np.array(smile), 90)

"""Распознавание эмодзи с 98 искаженными элементами"""

emoji_recognition(np.array(coolness), 98)

"""При большом количестве искаженных элементов НС дает неправильный результат.

Распознавание эмодзи со 100 искаженными элементами
"""

emoji_recognition(np.array(coolness), 100)

"""При изменении всех элементов начального эмодзи НС выдает неправильный результат

# Архитектура НС

Архитектура нейронной сети Хопфилда состоит из одного слоя из n нейронов, где каждый нейрон связан со всеми другими нейронами в сети. Эта сеть является рекуррентной и используется для ассоциативной памяти и распознавания образов. 
<p> Данная НС работает с матрицами размером 10*10, значит у нее количество нейронов равняется 100.

# Вывод

В результате тестирования нейронной сети Хопфилда на зашумленных версиях эмодзи было выяснено, что она может успешно извлекать исходные изображения из шумных входов даже при большом количестве искаженных элементов.
<p> При количестве искаженных элементов меньше 98 НС работает без ошибок, а при 98 искаженных элементов ошибка равняется 1/98. При искажении всех элементов изображения ошибка составляет 0,43.

В целом, нейронная сеть Хопфилда является простым и эффективным подходом к распознаванию образов и может быть применена к различным проблемам, где необходимо распознавание образов.
"""